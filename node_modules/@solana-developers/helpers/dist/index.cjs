"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addKeypairToEnvFile: () => addKeypairToEnvFile,
  airdropIfRequired: () => airdropIfRequired,
  confirmTransaction: () => confirmTransaction,
  createAccountsMintsAndTokenAccounts: () => createAccountsMintsAndTokenAccounts,
  getCustomErrorMessage: () => getCustomErrorMessage,
  getExplorerLink: () => getExplorerLink,
  getKeypairFromEnvironment: () => getKeypairFromEnvironment,
  getKeypairFromFile: () => getKeypairFromFile,
  getLogs: () => getLogs,
  getSimulationComputeUnits: () => getSimulationComputeUnits,
  initializeKeypair: () => initializeKeypair,
  keypairToSecretKeyJSON: () => keypairToSecretKeyJSON,
  makeKeypairs: () => makeKeypairs
});
module.exports = __toCommonJS(src_exports);
var import_web3 = require("@solana/web3.js");
var import_bs58 = __toESM(require("bs58"), 1);
var import_spl_token = require("@solana/spl-token");
var DEFAULT_FILEPATH = "~/.config/solana/id.json";
var DEFAULT_AIRDROP_AMOUNT = 1 * import_web3.LAMPORTS_PER_SOL;
var DEFAULT_MINIMUM_BALANCE = 0.5 * import_web3.LAMPORTS_PER_SOL;
var DEFAULT_ENV_KEYPAIR_VARIABLE_NAME = "PRIVATE_KEY";
var TOKEN_PROGRAM = import_spl_token.TOKEN_2022_PROGRAM_ID;
var getErrorFromRPCResponse = (rpcResponse) => {
  const error = rpcResponse.value.err;
  if (error) {
    if (typeof error === "object") {
      const errorKeys = Object.keys(error);
      if (errorKeys.length === 1) {
        if (errorKeys[0] !== "InstructionError") {
          throw new Error(`Unknown RPC error: ${error}`);
        }
        const instructionError = error["InstructionError"];
        throw new Error(
          `Error in transaction: instruction index ${instructionError[0]}, custom program error ${instructionError[1]["Custom"]}`
        );
      }
    }
    throw Error(error.toString());
  }
};
var keypairToSecretKeyJSON = (keypair) => {
  return JSON.stringify(Array.from(keypair.secretKey));
};
var getCustomErrorMessage = (possibleProgramErrors, errorMessage) => {
  const customErrorExpression = /.*custom program error: 0x(?<errorNumber>[0-9abcdef]+)/;
  let match = customErrorExpression.exec(errorMessage);
  const errorNumberFound = match?.groups?.errorNumber;
  if (!errorNumberFound) {
    return null;
  }
  const errorNumber = parseInt(errorNumberFound, 16);
  return possibleProgramErrors[errorNumber] || null;
};
var encodeURL = (baseUrl, searchParams) => {
  const url = new URL(baseUrl);
  url.search = new URLSearchParams(searchParams).toString();
  return url.toString();
};
var getExplorerLink = (linkType, id, cluster = "mainnet-beta") => {
  const searchParams = {};
  if (cluster !== "mainnet-beta") {
    if (cluster === "localnet") {
      searchParams["cluster"] = "custom";
      searchParams["customUrl"] = "http://localhost:8899";
    } else {
      searchParams["cluster"] = cluster;
    }
  }
  let baseUrl = "";
  if (linkType === "address") {
    baseUrl = `https://explorer.solana.com/address/${id}`;
  }
  if (linkType === "transaction" || linkType === "tx") {
    baseUrl = `https://explorer.solana.com/tx/${id}`;
  }
  if (linkType === "block") {
    baseUrl = `https://explorer.solana.com/block/${id}`;
  }
  return encodeURL(baseUrl, searchParams);
};
var getKeypairFromFile = async (filepath) => {
  const path = await import("path");
  if (!filepath) {
    filepath = DEFAULT_FILEPATH;
  }
  if (filepath[0] === "~") {
    const home = process.env.HOME || null;
    if (home) {
      filepath = path.join(home, filepath.slice(1));
    }
  }
  let fileContents;
  try {
    const { readFile } = await import("fs/promises");
    const fileContentsBuffer = await readFile(filepath);
    fileContents = fileContentsBuffer.toString();
  } catch (error) {
    throw new Error(`Could not read keypair from file at '${filepath}'`);
  }
  let parsedFileContents;
  try {
    parsedFileContents = Uint8Array.from(JSON.parse(fileContents));
  } catch (thrownObject) {
    const error = thrownObject;
    if (!error.message.includes("Unexpected token")) {
      throw error;
    }
    throw new Error(`Invalid secret key file at '${filepath}'!`);
  }
  return import_web3.Keypair.fromSecretKey(parsedFileContents);
};
var getKeypairFromEnvironment = (variableName) => {
  const secretKeyString = process.env[variableName];
  if (!secretKeyString) {
    throw new Error(`Please set '${variableName}' in environment.`);
  }
  let decodedSecretKey;
  try {
    decodedSecretKey = import_bs58.default.decode(secretKeyString);
    return import_web3.Keypair.fromSecretKey(decodedSecretKey);
  } catch (throwObject) {
    const error = throwObject;
    if (!error.message.includes("Non-base58 character")) {
      throw new Error(
        `Invalid secret key in environment variable '${variableName}'!`
      );
    }
  }
  try {
    decodedSecretKey = Uint8Array.from(JSON.parse(secretKeyString));
  } catch (error) {
    throw new Error(
      `Invalid secret key in environment variable '${variableName}'!`
    );
  }
  return import_web3.Keypair.fromSecretKey(decodedSecretKey);
};
var addKeypairToEnvFile = async (keypair, variableName, envFileName) => {
  const { appendFile } = await import("fs/promises");
  if (!envFileName) {
    envFileName = ".env";
  }
  const existingSecretKey = process.env[variableName];
  if (existingSecretKey) {
    throw new Error(`'${variableName}' already exists in env file.`);
  }
  const secretKeyString = keypairToSecretKeyJSON(keypair);
  await appendFile(
    envFileName,
    `
# Solana Address: ${keypair.publicKey.toBase58()}
${variableName}=${secretKeyString}`
  );
};
var initializeKeypair = async (connection, options) => {
  let {
    keypairPath,
    envFileName,
    envVariableName = DEFAULT_ENV_KEYPAIR_VARIABLE_NAME,
    airdropAmount = DEFAULT_AIRDROP_AMOUNT,
    minimumBalance = DEFAULT_MINIMUM_BALANCE
  } = options || {};
  let keypair;
  if (keypairPath) {
    keypair = await getKeypairFromFile(keypairPath);
  } else if (process.env[envVariableName]) {
    keypair = getKeypairFromEnvironment(envVariableName);
  } else {
    keypair = import_web3.Keypair.generate();
    await addKeypairToEnvFile(keypair, envVariableName, envFileName);
  }
  if (airdropAmount) {
    await airdropIfRequired(
      connection,
      keypair.publicKey,
      airdropAmount,
      minimumBalance
    );
  }
  return keypair;
};
var requestAndConfirmAirdrop = async (connection, publicKey, amount) => {
  const airdropTransactionSignature = await connection.requestAirdrop(
    publicKey,
    amount
  );
  const latestBlockHash = await connection.getLatestBlockhash();
  await connection.confirmTransaction(
    {
      blockhash: latestBlockHash.blockhash,
      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
      signature: airdropTransactionSignature
    },
    // "finalized" is slow but we must be absolutely sure
    // the airdrop has gone through
    "finalized"
  );
  return connection.getBalance(publicKey, "finalized");
};
var airdropIfRequired = async (connection, publicKey, airdropAmount, minimumBalance) => {
  const balance = await connection.getBalance(publicKey, "confirmed");
  if (balance < minimumBalance) {
    return requestAndConfirmAirdrop(connection, publicKey, airdropAmount);
  }
  return balance;
};
var confirmTransaction = async (connection, signature, commitment = "finalized") => {
  const block = await connection.getLatestBlockhash();
  const rpcResponse = await connection.confirmTransaction(
    {
      signature,
      ...block
    },
    commitment
  );
  getErrorFromRPCResponse(rpcResponse);
  return signature;
};
var makeKeypairs = (amount) => {
  return Array.from({ length: amount }, () => import_web3.Keypair.generate());
};
var getLogs = async (connection, tx) => {
  await confirmTransaction(connection, tx);
  const txDetails = await connection.getTransaction(tx, {
    maxSupportedTransactionVersion: 0,
    commitment: "confirmed"
  });
  return txDetails?.meta?.logMessages || [];
};
var getSimulationComputeUnits = async (connection, instructions, payer, lookupTables) => {
  const testInstructions = [
    // Set an arbitrarily high number in simulation
    // so we can be sure the transaction will succeed
    // and get the real compute units used
    import_web3.ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
    ...instructions
  ];
  const testTransaction = new import_web3.VersionedTransaction(
    new import_web3.TransactionMessage({
      instructions: testInstructions,
      payerKey: payer,
      // RecentBlockhash can by any public key during simulation
      // since 'replaceRecentBlockhash' is set to 'true' below
      recentBlockhash: import_web3.PublicKey.default.toString()
    }).compileToV0Message(lookupTables)
  );
  const rpcResponse = await connection.simulateTransaction(testTransaction, {
    replaceRecentBlockhash: true,
    sigVerify: false
  });
  getErrorFromRPCResponse(rpcResponse);
  return rpcResponse.value.unitsConsumed || null;
};
var makeMintInstructions = (mintAddress, ataAddress, amount, authority, payer = authority) => {
  return [
    // Initializes a new mint and optionally deposits all the newly minted tokens in an account.
    (0, import_spl_token.createInitializeMint2Instruction)(
      mintAddress,
      6,
      authority,
      null,
      TOKEN_PROGRAM
    ),
    // Create the ATA
    (0, import_spl_token.createAssociatedTokenAccountIdempotentInstruction)(
      payer,
      ataAddress,
      authority,
      mintAddress,
      TOKEN_PROGRAM
    ),
    // Mint some tokens to the ATA
    (0, import_spl_token.createMintToInstruction)(
      mintAddress,
      ataAddress,
      authority,
      amount,
      [],
      TOKEN_PROGRAM
    )
  ];
};
var makeAndSendAndConfirmTransaction = async (connection, instructions, signers, payer) => {
  const latestBlockhash = (await connection.getLatestBlockhash("max")).blockhash;
  const messageV0 = new import_web3.TransactionMessage({
    payerKey: payer.publicKey,
    recentBlockhash: latestBlockhash,
    instructions
  }).compileToV0Message();
  const transaction = new import_web3.VersionedTransaction(messageV0);
  transaction.sign(signers);
  const signature = await connection.sendTransaction(transaction);
  await confirmTransaction(connection, signature);
};
var createAccountsMintsAndTokenAccounts = async (usersAndTokenBalances, lamports, connection, payer) => {
  const userCount = usersAndTokenBalances.length;
  const mintCount = Math.max(
    ...usersAndTokenBalances.map((mintBalances) => mintBalances.length)
  );
  const users = makeKeypairs(userCount);
  const mints = makeKeypairs(mintCount);
  let tokenAccounts;
  tokenAccounts = users.map((user) => {
    return mints.map(
      (mint) => (0, import_spl_token.getAssociatedTokenAddressSync)(
        mint.publicKey,
        user.publicKey,
        false,
        TOKEN_PROGRAM
      )
    );
  });
  const sendSolInstructions = users.map(
    (user) => import_web3.SystemProgram.transfer({
      fromPubkey: payer.publicKey,
      toPubkey: user.publicKey,
      lamports
    })
  );
  const minimumLamports = await (0, import_spl_token.getMinimumBalanceForRentExemptMint)(connection);
  const createMintInstructions = mints.map(
    (mint) => import_web3.SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: mint.publicKey,
      lamports: minimumLamports,
      space: import_spl_token.MINT_SIZE,
      programId: TOKEN_PROGRAM
    })
  );
  const mintTokensInstructions = usersAndTokenBalances.flatMap((userTokenBalances, userIndex) => {
    return userTokenBalances.flatMap((tokenBalance, mintIndex) => {
      if (tokenBalance === 0) {
        return [];
      }
      return makeMintInstructions(
        mints[mintIndex].publicKey,
        tokenAccounts[userIndex][mintIndex],
        tokenBalance,
        users[userIndex].publicKey,
        payer.publicKey
      );
    });
  });
  const instructions = [
    ...sendSolInstructions,
    ...createMintInstructions,
    ...mintTokensInstructions
  ];
  const signers = [...users, ...mints, payer];
  await makeAndSendAndConfirmTransaction(
    connection,
    instructions,
    signers,
    payer
  );
  return {
    users,
    mints,
    tokenAccounts
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addKeypairToEnvFile,
  airdropIfRequired,
  confirmTransaction,
  createAccountsMintsAndTokenAccounts,
  getCustomErrorMessage,
  getExplorerLink,
  getKeypairFromEnvironment,
  getKeypairFromFile,
  getLogs,
  getSimulationComputeUnits,
  initializeKeypair,
  keypairToSecretKeyJSON,
  makeKeypairs
});
